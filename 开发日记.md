#### **前言**

此文将会回顾gobang开发过程以及其中遇到的困难，防止在开发的时候只有上帝和我知道逻辑，开发后只有上帝知道。

#### **初探**

​	该程序是在看到有dalao仅用19行写出五子棋，便想尝试实现以下。

​	说实话刚想如何实现时是一头雾水，不知从何入手，想来想去还是从最简单的print环节开始。

#### **dawn()函数**

​		首先是落子的记录方式，由于之前有开发控制台游戏的经历，所以就直接用**数组**来存储，这也给后面功能实现提供方便，当然也带来麻烦。

```c
void dawn(map[high][width])
{
    for (int i = 0; i < high; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (map[i][j] == 0)
            {
                _cprintf(" ");
            }
            else if (map[i][j] == 1)
            {
                _cprintf("O");
            }
            else
            {
                _cprintf("@");
            }
            if (j == (width - 1))
            {
                _cprintf("\n");
            }
        }
    }
}
```

​		一开始是这样写的，看上去没有问题，但一旦运行便会显露，由于二维数组在内存中是一维线性的，所以函数中二维数组应该用指针访问：

```
*(map[i] + j)=0;
```

这样才正常工作。

​		这里还有一个细节问题，由于历史原因，定义的函数名要加下划线`_`，当然加不加还是要看你的编译器。

#### main()函数

​		有了绘图，接下来是改变数组内容，这比较好做：

```flow
s=>start: 开始
e=>end: 结束
i=>inputoutput: 等待输入
o=>operation: 分辨输入
c=>condition: 判断是否有五棋
o1=>operation: 反应

s->c->e
c(yes)->e
c(no)->i->o->o1->i
```

```c
while (sum())
{
        ch = getch();//等待输入
        switch (ch) //分辨输入ASCll码
        {
        case 119: //w
            y--;
            break;
        case 115: //s
            y++;
            break;
        case 97://a
            x--;
            break;
        case 100://d
            x++;
            break;
        case 32://\r
            if (mod == 1)
            {
                map[y][x] = i;
                i *= -1;
            }
            else
            {
                map[y][x] = i;
                ai(y, x);
            }
            break;
        case 113://q
            mod *= -1;
            break;
        default:
            break;
        }
}
```

​		这里也有几个小地方值得注意，屏幕的`x-y`轴和数组的`x-y`不一样，在赋值时注意对应

#### sum()函数

​		这个对我来说是一个难点。需要实现以下功能：

- 竖向判断连续五子

- 横向判断连续五子

- 两个斜方向判断连续五子

​		这个函数我尝试了许多方法，如求和判断，连续函数判断。但都因不能满足全部要求而pass掉。
​这里想说一下连续函数判断：

​		逻辑很简单，遍历数组，若map`[x][y]`==map`[x][y+1]`便计数加一，横竖斜也类似，在测试过程中它的确有作用，当计数结果非常不符合预期，这是因为它会将每行的相同加在一起，解决办法还是有的，如创建数组存储，每行初始化。但代码十分臃肿，这跟我们采用数组数据结构是相关的。

​		最后解决问题是用了一个特别暴力的方法，但足够简洁，直观。

```
for (int i = 0; i < high; i++)
    {
        for (int j = 0; j < width - 4; j++)
        {
            if (map[i][j] == map[i][j + 1] 
            && map[i][j + 1] == map[i][j + 2] 
            && map[i][j + 2] == map[i][j + 3] 
            && map[i][j + 3] == map[i][j + 4] 
            && map[i][j] != 0)
            {
                return 0;
            }
        }
    }
```

​		emmm就这么暴力，其他方向亦可仿照。

#### **ai()函数**

​		来到了让我困惑了好久的AI模块。我一开始的想法是统计每个方向连续对手棋子个数，比出最多的一个。这就是根据我自己玩五指棋的方法来做。但以我现在知识很难将其代码化，还是数据结构的问题。就这样我给绕了进去，所以我选择放松放松。看到晚霞和蓝调，emm，来灵感了。

​		我转变了思路，AI以对手落子来判断，不仅减小判断范围，也很好表达。当然，这是以对手是进攻为前提的。

还记的map是int类型吗，我可以让AI求对手落子的8个方向3格的和，找出最大值的对向便可以做出拦截动作。

​		问题又来了，如何表达最大值的对向，对于8个方向实际上是`x+1，x，x-1`和`y+1, y , y-1`的组合，你想到了什么，对的，`for`循环，在求出最值时，对**for**循环中的控制量取反便可。

​		细节：

> 1.对于AI落子可能落在已有棋的特殊情况，我的解决方法是，生成-2~2的随机量，直到落的地方是空的，这样还是有特殊情况，所以随机一次便改变对手落子的位置存储。
>
> 2.在比较最大值时有一种特殊情况，便是最一开始，都为0时，这里的max存储变量在初始化时设为-1，便可规避。
>
> 3.这里因为对手落子时对map的赋值是1，所以可以比大小来判断，这也是为什么在切换模式时只能让人类用白棋，后面可以加转换。

​					

​		最后的效果还是非常不错的。

#### **重构**

​		之前是将map定义在main函数中，其实定义在函数外便可规避传递二维数组所带来的一系列问题，便可直接用map`[][]`

#### **改进**

​		受限于知识水平，代码还做不到dalao19行的优美。可以寻找更加好的数据结构，AI判断逻辑，赢家输出，空气墙回退。
