#### **前言**

此文将会回顾gobang开发过程以及其中遇到的困难。

#### **初探**

​	该程序是在看到有dalao仅用19行写出五子棋，便想尝试实现以下。

​	说实话刚想如何实现时是一头雾水，不知从何入手，想来想去还是从最简单的print环节开始。

#### **dawn()函数**

​		首先是落子的记录方式，由于之前有开发控制台游戏的经历，所以就直接用**数组**来存储，这也给后面功能实现提供方便，当然也带来麻烦。

```c
void dawn(map[high][width])
{
    for (int i = 0; i < high; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (map[i][j] == 0)
            {
                _cprintf(" ");
            }
            else if (map[i][j] == 1)
            {
                _cprintf("O");
            }
            else
            {
                _cprintf("@");
            }
            if (j == (width - 1))
            {
                _cprintf("\n");
            }
        }
    }
}
```

​		一开始是这样写的，看上去没有问题，但一旦运行便会显露，由于二维数组在内存中是一维线性的，所以函数中二维数组应该用指针访问：

```
*(map[i] + j)=0;
```

这样才正常工作。

​		这里还有一个细节问题，由于历史原因，定义的函数名要加下划线`_`，当然加不加还是要看你的编译器。

#### main()函数

​		有了绘图，接下来是改变数组内容，这比较好做：

```flow
s=>start: 开始
e=>end: 结束
i=>inputoutput: 等待输入
o=>operation: 分辨输入
c=>condition: 判断是否有五棋
o1=>operation: 反应

s->c->e
c(yes)->e
c(no)->i->o->o1->i
```

```c
while (sum())
{
        ch = getch();//等待输入
        switch (ch) //分辨输入ASCll码
        {
        case 119: //w
            y--;
            break;
        case 115: //s
            y++;
            break;
        case 97://a
            x--;
            break;
        case 100://d
            x++;
            break;
        case 32://\r
            if (mod == 1)
            {
                map[y][x] = i;
                i *= -1;
            }
            else
            {
                map[y][x] = i;
                ai(y, x);
            }
            break;
        case 113://q
            mod *= -1;
            break;
        default:
            break;
        }
}
```

​		这里也有几个小地方值得注意，屏幕的`x-y`轴和数组的`x-y`不一样，在赋值时注意对应

